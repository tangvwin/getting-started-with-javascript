
今天有同学在群里说：nodejs的api文档真水，没有其他编程语言的api文档明了。同学有这样的质疑是正常的。

JavaScript语言发展太快了，api文档跟不上语言的发展速度。文档刚弄好，javascript又发布一版。这真的是够了。但这并不能说明nodejs的api文档就很水，这里有玄学。

要开始谈callback函数的设计理念，就绕不开以下三个关键词：

- 异步处理
- 错误处理
- 开源社区

JavaScript的语言特性就是异步处理，一层套一层的异步调用，如果某个异步处理出了问题，该怎么告知调用者？JavaScript语言在早期并没有规范这块内容。这导致工程师很苦逼，不仅陷入在异步的调用中，最后连错误处理都变得异常的困难。

比如：工程师A开发一个函数，错误处理采用了方式A，而工程师B开发了一个函数，错误处理采用了方式B。工程师C在调用工程师A和工程师B定义的函数时，就完全陷入在差异化中。

开源社区集结了一批全世界最优秀的工程师，他们发现了这个问题，就提出了一个口号（原则）：错误优先处理。即：所有所有所有的工程师定义的所有所有所有异步函数的回调的第一个参数默认为错误参数。

就这么一个简单的口号，解决了所有异步调用的错误处理问题。

从这件事情的产生到最终的解决方案，JavaScript的设计理念真正诠释了优秀工程师是如何驾驭编程语言的。

有了一个原则：错误优先处理。我们写任何代码就很随性了。

```javascript
// 读取某个文件夹路径里的所有内容
fs.readdir('path', function(err) {
   if (err) {
       return;
   }
});
```

```javascript
// 读取某个文件内容
fs.readFile('file_path', function(error) {
   if (error) {
       return;
   }
});
```

```javascript
// 写入'hello, js'到某个文件中
fs.writeFile('file_path', 'Hello, JS', function(e) {
   if (e) {
       return;
   }
});
```

以上你不管是调用哪个异步函数，callback的第一个参数都是用来接收错误信息的。参数的名字？就显然不重要了，你随意的取。不过建议命名为err，这是所有优秀工程师的统一命名。

当错误问题解决了，那怎么知道该函数会不会返回结果内容呢？这当然是要查api文档啦。某一个异步函数是否返回结果内容，api文档都会清楚告知。但是！如果不差查api文档能不能知道是否返回结果呢？能！需要像福尔摩斯一样去推理。

- fs.readdir是读取目录下的所有文件名，这么明确的异步处理函数，你说会不会返回内容呢？答案肯定是会的，而且一定是个数组。注意readdir的作用，是返回所有文件名。
- fs.readFile是读取某个文件的内容，这么明确的异步处理函数，你说会不会返回内容呢？答案肯定是会的，而且一定是string。注意readFile的作用，是返回文件内容。
- fs.writeFile是将内容写入到某个文件，这么明确的异步处理函数，你说会不会返回内容呢？答案肯定是不会的。

通过函数的作用，来推理callback函数的返回内容就是这么简简单单。

那如果推理得知会返回内容，内容应该怎么获得呢？

前面的错误优先返回中，错误变量err会占据callback函数的第一个位置，那结果就是第二个位置。

```javascript
// 读取某个文件夹路径里的所有内容
fs.readdir('path', function(err, files) {
   if (err) {
       return;
   }

  console.log(files);
});
```

```javascript
// 读取某个文件内容
fs.readFile('file_path', function(err, file) {
   if (error) {
       return;
   }

  console.log(file);
});
```

谨记callback函数的设计理念：

1. 错误处理优先。
2. 依据函数作用推测是否有结果，如果有结果，结果参数在第二位。

不管是错误处理还是推理是否有结果返回，这样的设计理念体现出工程师与工程师之间的信任，javascript语言好像是更有人情味的编程语言。

如果你哪一天在使用一个第三方库发现回调函数没有遵从这个原则，我建议你赶紧把这个第三方库扔到大海里去，让它从你的生活中消失。这个作者不值得你信任。
